---
title: ""
author: "Alexssandro da Silva Oliveira"
date: "`r format(Sys.Date())`"
lang: pt
---

<br>

::: {style="border-top: 2px solid #003366;"}
:::

<br>


```{r setup, include=FALSE}
# Define opções padrão para todos os chunks de código no R Markdown
knitr::opts_chunk$set(
  echo = TRUE,         # Oculta o código nos resultados finais do documento
  warning = FALSE,     # Suprime mensagens de aviso (warnings)
  message = FALSE,     # Suprime mensagens informativas (como as de carregamento de pacotes)
  fig.width = 10,      # Define a largura padrão das figuras (em polegadas)
  fig.height = 6,      # Define a altura padrão das figuras (em polegadas)
  fig.align = 'center'
)

```


## Pacotes e Funções Necessárias

::: {style="text-align: justify"}

Nesta seção, carregamos todas as bibliotecas e funções utilizadas neste projeto. A verificação é realizada de forma automática e, posteriormente, as bibliotecas necessárias são carregadas para uso.

Para a elaboração deste estudo, empregaremos a linguagem de programação [**R**](http://www.R-project.org/), voltada para a manipulação, análise e visualização de dados, bem como o software livre de ambiente de desenvolvimento integrado [**RStudio**](https://posit.co/download/rstudio-desktop/).



```{r}
#| label: setup-plots
#| code-summary: "Algoritimos auxiliares"

# ------------------------------------------------------------------------------
# A. Importação de Dados
# ------------------------------------------------------------------------------

if(!require("gsheet")) install.packages("gsheet", quiet = TRUE) ; require("gsheet")    

# ------------------------------------------------------------------------------
# B. Manipulação e Visualização de Dados
# ------------------------------------------------------------------------------

if(!require("tidyverse")) install.packages("tidyverse", quiet = TRUE) ; require("tidyverse")  

if(!require("ggrepel")) install.packages("ggrepel", quiet = TRUE) ; require("ggrepel")   

if(!require("geomtextpath")) install.packages("broom", quiet = TRUE) ; require("geomtextpath") 

if(!require("corrplot")) install.packages("corrplot", quiet = TRUE) ; require("corrplot")   

if(!require("stats")) install.packages("stats", quiet = TRUE) ; require("stats")   

if(!require("viridis")) install.packages("viridis", quiet = TRUE) ; require("viridis")   

# ------------------------------------------------------------------------------
# C. Modelagem Estatística
# ------------------------------------------------------------------------------

if(!require("nlme")) install.packages("nlme", quiet = TRUE) ; require("nlme")       
if(!require("broom")) install.packages("broom", quiet = TRUE) ; require("broom")      
# ------------------------------------------------------------------------------
# D. Apresentação de Resultados
# ------------------------------------------------------------------------------

if(!require("DT")) install.packages("DT", quiet = TRUE) ; require("DT")         

if(!require("reactable")) install.packages("reactable", quiet = TRUE) ; require("reactable")  

# ==============================================================================
# Função 1: Cria uma tabela DT interativa com estilo limpo e minimalista.
# ==============================================================================

tabela_interativa <- function(dados, titulo_tabela) {
  #' @param dados Dataframe ou tibble a ser exibido.
  #' @param titulo_tabela String que será usada como título/caption da tabela.
  
  # A cor #06d6a0 foi mantida do seu código (verde/ciano).
  cor_titulo <- "#40916c" 
  
  DT::datatable(
    # Converter para data.frame é mais seguro para a função DT
    base::data.frame(dados),
    
    # Configuração da Legenda (Caption)
    caption = htmltools::tags$caption(
      style = base::paste0("caption-side: top; text-align: center; color:", cor_titulo, ";"),
      htmltools::strong(titulo_tabela) # Usa o título fornecido como argumento
    ),
    
    # Estilo CSS da tabela
    class = "hover", 
    
    # Opções de funcionalidade (Configurações Minimalistas)
    options = list(
      pageLength = 8,       # Mostra 8 linhas por página
      searching = FALSE,    # Remove a barra de busca
      lengthChange = FALSE, # Remove o menu "Mostrar X entradas"
      info = FALSE,         # Remove o rodapé "Mostrando 1 a X de Y"
      ordering = FALSE,     # Remove as setas de ordenação nas colunas
      
      # Tradução dos botões
      language = list(
        paginate = list("previous" = "Anterior", "next" = "Próximo"),
        emptyTable = "Não há dados disponíveis na tabela",
        zeroRecords = "Nenhum registro correspondente encontrado"
      )
    )
  )
}
```

:::

## Base Dados: Recuperação de Pacientes Pós-AVC (STROKE)

### Sobre os dados

::: {style="text-align: justify"}

O conjunto de dados abaixo contempla informações de um experimento para promover a recuperação de 24 pacientes que sofreram derrame. O objetivo é avaliar a eficácia de diferentes regimes de terapia ao longo de 8 semanas.

Definição dos índices:

- $\mathbf{i}$: Representa o indivíduo (paciente), variando de $i=1, \dots, m$, onde $\mathbf{m = 24}$.
- $\mathbf{j}$: Representa a medição repetida (instante no tempo), variando de $j=1, \dots, n_{i}$, onde $\mathbf{n_i = 8}$.

Os pacientes foram divididos em três grupos experimentais. Embora cada grupo tenha o mesmo número de participantes (8 indivíduos), o balanceamento estatístico relevante em estudos longitudinais está associado ao número igual de medições ao longo do tempo por indivíduo $(n_i = 8)$, e não necessariamente ao fato de os grupos possuírem tamanhos iguais.

-   **Grupo A:** Uma nova intervenção de terapia ocupacional;
-   **Grupo B:** O programa existente de reabilitação de derrame;
-   **Grupo C:** O regime de cuidados usuais para pacientes com derrame.

:::

<br>

### Importação, Reestruturação e Tratamento dos Dados

::: {style="text-align: justify"}
Para a modelagem longitudinal, o conjunto de dados é submetido a três fases cruciais de processamento e estruturação:

-   **Passo 1 - Leitura:** Importação da base de dados brutos para o ambiente R no formato largo (wide). Nesse formato, cada linha representa um paciente e cada coluna corresponde a uma semana de avaliação. O banco original contém 24 linhas $(m = 24)$ e 10 variáveis: Sujeito, Grupo e as oito colunas $(n_i = 8)$ referentes às semanas (Semana 1 a Semana 8). Embora adequado para armazenar os dados brutos, esse formato não é apropriado para ajustes de modelos longitudinais.

```{r}
#| label: Importação da base de dados
#| code-summary: "Importação da base de dados"
# URL pública da planilha contendo os dados do experimento
url_stroke <- "https://docs.google.com/spreadsheets/d/1n394dzsNn1QITgigbHJ21uz6hi5TDCHs/edit?gid=712419062#gid=712419062"

# Nomes desejados para as variaveis
variaveis <- c("Sujeito", "Grupo", "Semana 1", "Semana 2", "Semana 3", 
           "Semana 4", "Semana 5", "Semana 6", "Semana 7", "Semana 8")

# Passo 1: Leitura e Renomeação: bd_stroke (Wide)
bd_stroke <- gsheet::gsheet2tbl(url_stroke) %>% stats::setNames(variaveis ) 

dplyr::glimpse(bd_stroke)

```

-   **Passo 2 - Reestruturação:** Para permitir a modelagem da correlação intra-sujeito ao longo do tempo, o banco é convertido para o formato longo (long), no qual cada linha representa uma única observação temporal (por exemplo, o registro de um paciente na Semana 3). As oito colunas das semanas são pivotadas para duas novas variáveis: Semana e Pontuação. Após essa reorganização, o conjunto de dados passa a conter 192 linhas e 4 variáveis: Sujeito, Grupo, Semana, Pontuação, totalizando: $m \times n_i = 24 \times 8 = 192$ observações.

-   **Passo 3 - Criação de Variável:** Se necessário, deve ser realizada a criação da variável de tempo recentralizada (no nosso caso semana), que é crucial para garantir que o intercepto do modelo estatístico ($\beta_0$) represente a Pontuacao basal (Semana 1 = Tempo 0).


```{r}
#| label: Reestruturação e tratamento dos dados
#| code-summary: "Reestruturação e tratamento dos dados"

bd_stroke_long <- bd_stroke %>%
  # Passo 2: Reestruturação de Dados (Wide -> Long)
  tidyr::pivot_longer(
    cols = `Semana 1`:`Semana 8`,  
    names_to = "Semana",           
    values_to = "Pontuacao"        
  ) %>%
  # Passo 3: Engenharia de Variáveis 
  dplyr::mutate(
    Semana = as.numeric(stringr::str_remove(.data$Semana, "Semana ")),
    Semana_recentralizada = .data$Semana - 1
  )

# Descritiva 
dplyr::glimpse(bd_stroke_long)
```


```{r}
#| label: Visualização dos dados reestruturados
#| code-summary: "Visualização dos dados reestruturados"

tabela_interativa(dados = bd_stroke_long,
                  titulo_tabela = "Dados longitudinais de Recuperação de Pacientes Pós-AVC")

```

<br>

Veja bem, cada $Y_{ij}$ (Resposta do indivíduo $i$ no tempo $j$) está associada a um tempo $t_{ij}$, de modo que a resposta observada para o indivíduo $i$ pode ser organizada em um vetor coluna de dimensão $n_i \times 1$. Assim, o conjunto de respostas do indivíduo $i$ é representado por:

$$
\mathbf{Y}_i =
\begin{pmatrix}
Y_{i1} \\
Y_{i2} \\
\vdots \\
Y_{in_i}
\end{pmatrix},
\qquad
\mathbf{t}_i =
\begin{pmatrix}
t_{i1} \\
t_{i2} \\
\vdots \\
t_{in_i}
\end{pmatrix}.
$$

Tomamos como exemplo o primeiro indivíduo ($i = 1$):

$$
\mathbf{Y}_i
=
\begin{pmatrix}
Y_{i1} \\
Y_{i2} \\
\vdots \\
Y_{in_i}
\end{pmatrix}_{n_i \times 1}
=
\begin{pmatrix}
Y_{11} \\
Y_{12} \\
Y_{13} \\
Y_{14} \\
Y_{15} \\
Y_{16} \\
Y_{17} \\
Y_{18}
\end{pmatrix}_{8 \times 1}
=
\begin{pmatrix}
45 \\
45 \\
45 \\
45 \\
80 \\
80 \\
80 \\
90
\end{pmatrix}_{8 \times 1}.
$$
De forma análoga, podemos escrever o vetor de respostas $\mathbf{Y}_i$ para o i-ésimo indivíduo da amostra.

:::

<br>

### Análise exploratória de dados (AED)

::: {style="text-align: justify"}

```{r}
#| label: Análise exploratória
#| code-summary: "Análise exploratória"

# Filtrando A e B
bd_stroke_long <- bd_stroke_long %>%
  filter(Grupo %in% c("A", "B"))

medias_semana <- bd_stroke_long %>%
  group_by(Grupo, Semana) %>%
  summarise(media_semana = mean(Pontuacao), .groups = "drop") %>%
  mutate(media_semana = round(media_semana, 1))

# Grafico de Spaghetti + Medias
ggplot() +
  geom_line(
    data = bd_stroke_long,
    aes(x = Semana, y = Pontuacao, group = Sujeito, color = Grupo),
    alpha = 0.5, linewidth = 0.6
  ) +
  geom_point(
    data = bd_stroke_long,
    aes(x = Semana, y = Pontuacao, color = Grupo),
    alpha = 0.9, size = 2
  ) +
  
  geom_line(
    data = medias_semana,
    aes(x = Semana, y = media_semana),
    color = "black", linewidth = 1
  ) +
  geom_point(
    data = medias_semana,
    aes(x = Semana, y = media_semana),
    color = "black", size = 2
  ) +
  
  ggrepel::geom_text_repel(
    data = medias_semana,
    aes(x = Semana, y = media_semana, label = media_semana),
    size = 4,
    fontface = "bold",
    color = "black",
    nudge_y = 2,
    box.padding = 0.4,
    min.segment.length = 0
  ) +
  
  facet_wrap(~Grupo) +
  theme_bw() +
  labs(
    title = "Trajetórias Individuais e Média por Semana (Grupos: A - Tratamento e B - Controle)",
    subtitle = "Cada número representa a média da semana dentro do grupo",
    x = "Semana",
    y = "Pontuação",
    color = "Grupo"
  ) + guides(color = "none")   # ← remove a legenda dos grupos

# Matriz de correlação
bd_cor <- bd_stroke %>% 
  filter(Grupo %in% c("A", "B")) %>%  # Filtrando A e B
  select(`Semana 1`:`Semana 8`) 

mat_cor <- cor(bd_cor, use = "pairwise.complete.obs")

corrplot(
  mat_cor,
  method = "color",
  type = "upper",
  tl.col = "black",
  tl.srt = 90,
  addCoef.col = "black",
  col = colorRampPalette(c("#F0F7FF", "#D4E8FF", "#A6CEFF", "#6CA9FF", "#2F6ECC"))(200),
  number.cex = 0.8
)

```


:::

<br>

### Modelo de Regressão Linear com Erros Correlacionados (GLS) para Dados Longitudinais


#### Modelo de Regressão Linear

::: {style="text-align: justify"}

O modelo de regressão linear clássico pode ser escrito na forma matricial:

$$
\mathbf{y} = \mathbf{X}\boldsymbol{\beta} + \boldsymbol{\varepsilon},
$$

$$
y_i = \mathbf{x}_i^\top \boldsymbol{\beta} + \varepsilon_i, \quad i = 1, \dots, n,
$$

em que:

- $\mathbf{y}$: vetor de respostas;  
- $\mathbf{X}$: matriz de preditores;  
- $\boldsymbol{\beta}$: vetor de coeficientes desconhecidos;  
- $\boldsymbol{\varepsilon}$: vetor de erros.

:::

<br>

#### Estrutura dos Erros - Estimação por  Mínimos quadrados ordinários (MQO)

::: {style="text-align: justify"}

No modelo clássico, assume-se que os erros seguem distribuição normal, com média zero e variância constante:

$$
\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \sigma^2 \mathbf{I}),
$$

ou seja, **independentes** e **homocedásticos**. Essas condições garantem que o estimador de mínimos quadrados ordinários (MQO) é dado por:

$$
\widehat{\boldsymbol{\beta}}_{\text{MQO}} = (\mathbf{X}^\top \mathbf{X})^{-1} \mathbf{X}^\top \mathbf{y},
$$

seja o **melhor estimador linear não viesado (BLUE)**.

:::

<br>

#### Estrutura dos Erros - Estimação por Mínimos Quadrados Generalizados (GLS)

::: {style="text-align: justify"}

Quando as suposições clássicas não são atendidas, por exemplo, quando há **heterocedasticidade** ou **correlação entre observações**, a matriz de covariância dos erros deixa de ser proporcional à identidade:

$$
\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \boldsymbol{\Sigma}),
$$

com $\boldsymbol{\Sigma}$ **não diagonal**, ou seja, com covariâncias diferentes de zero entre algumas observações.  

Nessas situações, o uso do estimador de **Mínimos Quadrados Generalizados (GLS)** torna-se mais apropriado. O GLS é definido como:

$$
\widehat{\boldsymbol{\beta}}_{\text{GLS}} = (\mathbf{X}^\top \boldsymbol{\Sigma}^{-1}\mathbf{X})^{-1} \mathbf{X}^\top \boldsymbol{\Sigma}^{-1}\mathbf{y},
$$

e é eficiente mesmo quando há **dependência entre observações** ou **variâncias diferentes**.  

Um aspecto importante é que, no GLS, podemos especificar diferentes estruturas para a matriz de covariância $\boldsymbol{\Sigma}$ de acordo com o comportamento dos dados.

:::

<br>

#### Por que o GLS é útil em estudos longitudinais ?

::: {style="text-align: justify"}

1. **Dependência entre observações:** Em dados longitudinais, cada indivíduo é medido várias vezes ao longo do tempo. Isso cria correlação entre as observações de um mesmo indivíduo, violando a suposição de independência do modelo linear clássico.

2. **Variância não constante:** As medidas repetidas podem apresentar variâncias diferentes ao longo do tempo ou entre indivíduos (**heterocedasticidade**).

A seguir, apresentamos três estruturas bastante utilizadas em modelos com correlação dentro do indivíduo.

:::

<br>

#### Estruturas de Covariância Comuns

<br>

##### Compound Symmetry (CS):

::: {style="text-align: justify"}

**Pressupostos:** Todas as variâncias são iguais e todas as covariâncias entre observações do mesmo indivíduo são constantes.  

**Matriz de covariância:**

$$
\boldsymbol{\Sigma}_{CS} =
\begin{pmatrix}
\sigma^2      & \rho\sigma^2 & \cdots & \rho\sigma^2 \\
\rho\sigma^2  & \sigma^2     & \cdots & \rho\sigma^2 \\
\vdots        & \vdots       & \ddots & \vdots \\
\rho\sigma^2  & \rho\sigma^2 & \cdots & \sigma^2
\end{pmatrix}.
$$

**Modelo GLS na forma matricial:**

$$
\mathbf{y} = \mathbf{X}\boldsymbol{\beta} + \boldsymbol{\varepsilon}, \quad
\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \boldsymbol{\Sigma}_{CS}).
$$

**Modelo por observação:**

$$
y_{ij} = \mathbf{x}_{ij}^\top \boldsymbol{\beta} + \varepsilon_{ij}, \quad
\text{com } \text{Cov}(\varepsilon_{ij}, \varepsilon_{ik}) = \rho \sigma^2, \; j \neq k.
$$

<br>

##### Autorregressiva de Ordem 1 (AR(1)):

**Pressupostos:** As observações de um mesmo indivíduo apresentam correlação que **decai exponencialmente** com a distância temporal.  

**Matriz de covariância:**

$$
\boldsymbol{\Sigma}_{AR(1)} =
\begin{pmatrix}
\sigma^2 & \rho\sigma^2 & \rho^2\sigma^2 & \cdots & \rho^{n-1}\sigma^2 \\
\rho\sigma^2 & \sigma^2 & \rho\sigma^2 & \cdots & \rho^{n-2}\sigma^2 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
\rho^{n-1}\sigma^2 & \rho^{n-2}\sigma^2 & \cdots & \rho\sigma^2 & \sigma^2
\end{pmatrix}.
$$

**Modelo GLS na forma matricial:**

$$
\mathbf{y} = \mathbf{X}\boldsymbol{\beta} + \boldsymbol{\varepsilon}, \quad
\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \boldsymbol{\Sigma}_{AR(1)}).
$$

**Modelo por observação:**

$$
y_{ij} = \mathbf{x}_{ij}^\top \boldsymbol{\beta} + \varepsilon_{ij}, \quad
\text{tal que Cov}(\varepsilon_{ij}, \varepsilon_{ik}) = \sigma^2 \rho^{|j-k|}.
$$

<br>

##### Não Estruturada (Symm):

**Pressupostos:** Todas as variâncias e covariâncias são livres, permitindo máxima flexibilidade, assumindo apenas simetria.  

**Matriz de covariância:**

$$
\boldsymbol{\Sigma}_{Symm} =
\begin{pmatrix}
\sigma_{11} & \sigma_{12} & \cdots & \sigma_{1n} \\
\sigma_{21} & \sigma_{22} & \cdots & \sigma_{2n} \\
\vdots      & \vdots      & \ddots & \vdots \\
\sigma_{n1} & \sigma_{n2} & \cdots & \sigma_{nn}
\end{pmatrix}, \quad \sigma_{ij} = \sigma_{ji}.
$$

**Modelo GLS na forma matricial:**

$$
\mathbf{y} = \mathbf{X}\boldsymbol{\beta} + \boldsymbol{\varepsilon}, \quad
\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \boldsymbol{\Sigma}_{Symm}).
$$

**Modelo por observação:**

$$
y_{ij} = \mathbf{x}_{ij}^\top \boldsymbol{\beta} + \varepsilon_{ij}, \quad
\text{tal que Cov}(\varepsilon_{ij}, \varepsilon_{ik}) = \sigma_{jk}.
$$

::: 

### Modelos

```{r}
#| label: Modelagem
#| code-summary: "Modelagem"

# Modelo CS (Simetria Composta) - Correlação constante
mod_cs <- nlme::gls(
  model = Pontuacao ~ Grupo * Semana_recentralizada,
  data = bd_stroke_long,
  correlation = nlme::corCompSymm(form = ~ 1 | Sujeito),
  method = "REML"
)

# Modelo AR1 (Autorregressivo) - Correlação decai com o tempo
mod_ar1 <- nlme::gls(
  model = Pontuacao ~ Grupo * Semana_recentralizada,
  data = bd_stroke_long,
  correlation = nlme::corAR1(form = ~ Semana_recentralizada | Sujeito),
  method = "REML"
)

# Modelo SYMM (Não Estruturado)
mod_symm <- nlme::gls(
  model = Pontuacao ~ Grupo * Semana_recentralizada,
  data = bd_stroke_long,
  correlation = nlme::corSymm(form = ~ 1 | Sujeito),
  method = "REML"
)
```

#### Critérios de Seleção de Modelo

::: {style="text-align: justify"}

O objetivo desta seção é apresentar critérios utilizados para comparar e selecionar modelos ajustados, considerando a **qualidade do ajuste** e a **complexidade do modelo**.

::: 

<br>

##### AIC (Critério de Informação de Akaike)

::: {style="text-align: justify"}

O **AIC** penaliza modelos complexos e ajuda a evitar sobreajuste:

$$
\text{AIC} = -2 \log L(\widehat{\boldsymbol{\theta}}) + 2k
$$

**Rótulos:**

- $L(\widehat{\boldsymbol{\theta}})$: função de verossimilhança avaliada nos parâmetros estimados;  
- $k$: número de parâmetros do modelo;  
- $-2 \log L(\cdot)$: medida de ajuste do modelo aos dados;  
- $2k$: penalização pelo número de parâmetros.

**Interpretação:** modelos com **AIC menor** são preferíveis.

::: 

<br>

##### BIC (Critério de Informação Bayesiano)

::: {style="text-align: justify"}

O **BIC** penaliza modelos complexos de forma mais forte, especialmente em grandes amostras:

$$
\text{BIC} = -2 \log L(\widehat{\boldsymbol{\theta}}) + k \log(n)
$$

**Rótulos:**

- $L(\widehat{\boldsymbol{\theta}})$: função de verossimilhança nos parâmetros estimados;  
- $k$: número de parâmetros do modelo;  
- $n$: tamanho da amostra;  
- $-2 \log L(\cdot)$: medida de ajuste;  
- $k \log(n)$: penalização pelo número de parâmetros.

**Interpretação:** modelos com **BIC menor** são preferíveis.

::: 

<br>

##### Teste da Razão de Verossimilhança (TRV)

::: {style="text-align: justify"}

O **Teste da Razão de Verossimilhança** compara dois modelos **aninhados**:

$$
\Lambda = -2 \big[ \log L(\text{Modelo restrito}) - \log L(\text{Modelo completo}) \big]
$$

**Rótulos:**

- $\log L(\text{Modelo restrito})$: log-verossimilhança do modelo mais simples;  
- $\log L(\text{Modelo completo})$: log-verossimilhança do modelo mais complexo;  
- $\Lambda$: estatística do teste, aproximadamente qui-quadrado com $df = k_{\text{completo}} - k_{\text{restrito}}$.

**Hipóteses:**

- $H_0$: modelo restrito é suficiente;  
- $H_1$: modelo completo ajusta melhor os dados.

**Interpretação:** rejeitar $H_0$ indica que o modelo completo ajusta melhor.


```{r}
#| label: Comparacao_modelos
#| code-summary: "Comparacao_modelos"

# Comparação de modelos pelo Critério AIC
aic_result <- stats::AIC(mod_cs, mod_ar1, mod_symm)
print(aic_result)

# Comparação de modelos pelo Critério BIC
stats::BIC(mod_cs, mod_ar1, mod_symm)

# Teste da Razão de Verossimilhança (LRT) entre modelos aninhados
print(stats::anova(mod_cs, mod_ar1))
print(stats::anova(mod_ar1, mod_symm))
print(stats::anova(mod_cs, mod_symm))

```

:::

<br>

#### Modelo Proposto AR(1)


::: {style="text-align: justify"}

Forma Geral


$$
\mathbf{y}_{it} = \beta_0 + \beta_1 X_{1i} + \beta_2 X_{2t} + \beta_3 (X_{1i} \times X_{2t}) + \varepsilon_{it}, 
\quad 
\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \boldsymbol{\Sigma}_{AR(1)})
$$

onde:

- $i$ indica o indivíduo;  
- $t$ indica o tempo;  
- $\boldsymbol{\Sigma}_{AR(1)}$ é a matriz de covariância AR(1) com correlação $\text{Cor}(\varepsilon_{it}, \varepsilon_{is}) = \phi^{|t-s|}$.

$$
Y_{it} = \beta_0 + \beta_1 \;\text{Grupo}_{i} + \beta_2 \;\text{Semana Recentralizada}_{t} + \beta_3 \; (\text{Grupo}_i \times \text{Semana Recentralizada}_t) + \varepsilon_{it}, 
\quad 
\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \boldsymbol{\Sigma}_{AR(1)})
$$

Onde $\phi = 0.943$ estimado a partir dos dados.


::: 

<br>

##### Estimativas do Modelo

```{r}
#| label: Estimativas
#| code-summary: "Estimativas"

summary(mod_ar1)
```


<br>

##### Interpretação do Modelo AR(1)

::: {style="text-align: justify"}

O modelo AR(1) ajusta a pontuação dos indivíduos ao longo das semanas, considerando a correlação temporal entre medidas do mesmo sujeito.  

**Coeficientes estimados:**

- **Intercepto ($\beta_0 = 39.41$):** representa a pontuação média do **Grupo A** na **semana centralizada = 0**.  
- **GrupoB ($\beta_1 = -2.16$, p = 0.8403):** diferença média entre o **Grupo B** e o Grupo A na semana centralizada = 0. Como o p-valor é alto, não há evidência de diferença significativa nesse ponto.  
- **Semana_recentralizada ($\beta_2 = 6.08$, p < 0.0001):** efeito médio da semana sobre a pontuação no Grupo A. Indica que, a cada aumento de uma unidade na semana, a pontuação do Grupo A aumenta em média 6.08 pontos, sendo estatisticamente significativo.  
- **Interação GrupoB:Semana_recentralizada ($\beta_3 = -2.14$, p = 0.0906):** diferença no efeito do tempo entre o Grupo B e o Grupo A. O p-valor sugere que não é estatisticamente significativo ao nível de 5%, mas indica uma tendência de menor aumento no Grupo B ao longo das semanas.  

**Parâmetro de correlação ($\phi = 0.943$):** indica forte correlação positiva entre medidas consecutivas do mesmo indivíduo, confirmando que a estrutura AR(1) é adequada para modelar a dependência temporal.  

**Conclusão:**  
O modelo sugere que, independentemente do grupo, a pontuação tende a aumentar ao longo do tempo. Não há evidência de diferença significativa entre os grupos na semana inicial, nem uma interação forte entre grupo e tempo, embora exista uma tendência do Grupo B apresentar aumento mais lento. A correlação temporal foi bem capturada pelo modelo AR(1).

:::

<br>


## Base Dados: Peso de Bezerros

### Sobre os dados

::: {style="text-align: justify"}
O objetivo deste estudo é explorar o crescimento de bezerros entre a 12ª e a 26ª semana de vida, utilizando dados longitudinais com medidas repetidas.

Definição dos índices:

- $\mathbf{m = 15}$.
- $\mathbf{n_i = 8}$.


:::

<br>


::: {style="text-align: justify"}


```{r}
# ------------------------------------------------------------------------------
# PACOTES
# ------------------------------------------------------------------------------
library(geomtextpath)
library(ggrepel)

# ------------------------------------------------------------------------------
# 1. IMPORTAÇÃO DOS DADOS
# ------------------------------------------------------------------------------
url_bezerros <- "https://docs.google.com/spreadsheets/d/1BGP2yokaV8uiQ1kJXP3BvfXbDoBgw9Jb/edit?gid=1419069632#gid=1419069632"

bd_bezerros <- gsheet::gsheet2tbl(url_bezerros)

glimpse(bd_bezerros)

# ------------------------------------------------------------------------------
# 2. TRANSFORMAÇÃO DOS DADOS (WIDE → LONG)
# ------------------------------------------------------------------------------

bd_bezerros_long <- bd_bezerros %>%
  pivot_longer(
    cols = t12:t26,
    names_to = "tempo",
    values_to = "valor"
  ) %>%
  mutate(
    tempo_num = as.numeric(str_remove(tempo, "t")),
    tempo_recentralizado = tempo_num - min(tempo_num)
  )

glimpse(bd_bezerros_long)

# ------------------------------------------------------------------------------
# 3. GRÁFICO SPAGHETTI + MÉDIA GERAL
# ------------------------------------------------------------------------------

medias_tempo <- bd_bezerros_long %>%
  group_by(tempo_num) %>%
  summarise(media = mean(valor), .groups = "drop") %>%
  mutate(media = round(media, 1))

grafico_bezerros <- ggplot() +
  geom_line(
    data = bd_bezerros_long,
    aes(x = tempo_num, y = valor, group = ind, color = factor(ind)),
    alpha = 0.7, linewidth = 1
  ) +
  geom_point(
    data = bd_bezerros_long,
    aes(x = tempo_num, y = valor, color = factor(ind)),
    size = 2
  ) +
  
  # Médias
  geom_line(
    data = medias_tempo,
    aes(x = tempo_num, y = media),
    color = "black", linewidth = 1.3
  ) +
  geom_point(
    data = medias_tempo,
    aes(x = tempo_num, y = media),
    color = "black", size = 3
  ) +
  geom_text_repel(
    data = medias_tempo,
    aes(x = tempo_num, y = media, label = media),
    size = 4,
    fontface = "bold",
    nudge_y = 3,
    box.padding = 0.4
  ) +
  
  scale_color_viridis_d(option = "turbo") +   # Paleta moderna, ótima para distinguir indivíduos
  guides(color = guide_legend(title = "Indivíduo")) +
  
  theme_bw() +
  labs(
    title = "Trajetórias Individuais com Cores (Bezerros)",
    subtitle = "Cada cor representa um animal (ind)",
    x = "Tempo (dias/medidas)",
    y = "Valor"
  ) + guides(color = "none")  

print(grafico_bezerros)

# ------------------------------------------------------------------------------
# 4. MATRIZ DE CORRELAÇÃO
# ------------------------------------------------------------------------------
bd_cor <- bd_bezerros %>% select(t12:t26)

mat_cor <- cor(bd_cor, use = "pairwise.complete.obs")

corrplot(
  mat_cor,
  method = "color",
  type = "upper",
  tl.col = "black",
  tl.srt = 90,
  addCoef.col = "black",
  number.cex = 0.8,
  col = colorRampPalette(c("#F0F7FF", "#D4E8FF",
                           "#A6CEFF", "#6CA9FF", 
                           "#2F6ECC"))(200)
)

# ------------------------------------------------------------------------------
# 5. MODELOS GLS (apenas um grupo)
# ------------------------------------------------------------------------------

# Y = valor
# X = tempo_recentralizado
# ID = ind

mod_cs_bez <- nlme::gls(
  model = valor ~ tempo_recentralizado,
  data = bd_bezerros_long,
  correlation = nlme::corCompSymm(form = ~ 1 | ind),
  method = "REML"
)

mod_ar1_bez <- nlme::gls(
  model = valor ~ tempo_recentralizado,
  data = bd_bezerros_long,
  correlation = nlme::corAR1(form = ~ tempo_recentralizado | ind),
  method = "REML"
)

mod_symm_bez <- nlme::gls(
  model = valor ~ tempo_recentralizado,
  data = bd_bezerros_long,
  correlation = nlme::corSymm(form = ~ 1 | ind),
  method = "REML"
)

# ------------------------------------------------------------------------------
# 6. COMPARAÇÃO ENTRE MODELOS
# ------------------------------------------------------------------------------

print(AIC(mod_cs_bez, mod_ar1_bez, mod_symm_bez))
print(BIC(mod_cs_bez, mod_ar1_bez, mod_symm_bez))

# LRT – Razão de Verossimilhança
print(anova(mod_cs_bez, mod_ar1_bez))
print(anova(mod_ar1_bez, mod_symm_bez))
print(anova(mod_cs_bez, mod_symm_bez))

```

O modelo GLS com correlação composta (CS) ajustado aos dados dos bezerros pode ser formulado como:

$$
Y_{it} = \beta_0 + \beta_1 \, \text{Tempo Recentralizado}_{t} + \varepsilon_{it}, 
\quad 
\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \boldsymbol{\Sigma}_{CS})
$$

onde:  

- $i$ indica o indivíduo;  
- $t$ indica o tempo;  
- $\boldsymbol{\Sigma}_{CS}$ é a matriz de covariância com **correlação constante** entre observações do mesmo indivíduo:  
  $$
  \text{Cor}(\varepsilon_{it}, \varepsilon_{is}) = \rho, \quad \forall \, t \neq s
  $$  
- $\rho = 0.918$ é o valor estimado a partir dos dados.


```{r}
summary(mod_cs_bez)
```

:::

<br>

## Base Dados: PA

### Sobre os dados

::: {style="text-align: justify"}

O conjunto de dados analisado contempla informações de um estudo longitudinal realizado com 100 pacientes, com o objetivo de avaliar a evolução da pressão arterial sistólica ($Y$) ao longo do tempo e investigar o efeito do nível de atividade física.

Em cada visita, foram registrados:

- tempo: número da consulta ($j = 1, \dots, 10$), com intervalos regulares;
- min_atividade_fisica: tempo médio semanal de atividade física;
- PA: pressão arterial sistólica.

Definição dos índices:

- $i$: indivíduo (paciente), variando de $i = 1, \dots, m$, com $m = 100$;
- $j$: medição repetida (instante no tempo), variando de $j = 1, \dots, n_i$, com $n_i = 10$


<br>


```{r}
bd_pa <- read_delim(
  "pa.txt", 
  delim = "\t", 
  escape_double = FALSE, 
  trim_ws = TRUE
)

# Remover coluna extra se existir
if("...1" %in% names(bd_pa)) bd_pa <- bd_pa %>% select(-...1)

# Garantir tipos corretos
bd_pa <- bd_pa %>%
  mutate(
    id = factor(id),
    tempo = as.numeric(tempo)
  )

glimpse(bd_pa)

# ------------------------------------------------------------------------------
# 2. CÁLCULO DAS MÉDIAS POR TEMPO
# ------------------------------------------------------------------------------
medias_pa <- bd_pa %>%
  group_by(tempo) %>%
  summarise(media = round(mean(PA),1), .groups = "drop")

# ------------------------------------------------------------------------------
# 3. GRÁFICO SPAGHETTI COM MÉDIAS
# ------------------------------------------------------------------------------
grafico_pa <- ggplot() +
  # Trajetórias individuais
  geom_line(data = bd_pa, aes(x = tempo, y = PA, group = id, color = id),
            alpha = 0.5, linewidth = 0.7) +
  geom_point(data = bd_pa, aes(x = tempo, y = PA, color = id), size = 1.8) +
  # Média por tempo
  geom_line(data = medias_pa, aes(x = tempo, y = media), color = "black", linewidth = 1.3) +
  geom_point(data = medias_pa, aes(x = tempo, y = media), color = "black", size = 2.5) +
  # Valores da média
  geom_text_repel(
    data = medias_pa,
    aes(x = tempo, y = media, label = media),
    size = 4,
    fontface = "bold",
    nudge_y = 2,
    box.padding = 0.3
  ) +
  scale_color_viridis_d(option = "turbo") +
  guides(color = guide_legend(title = "ID")) +
  theme_bw() +
  labs(
    title = "Trajetórias Individuais de PA com Média por Tempo",
    subtitle = "Cores representam indivíduos; linha preta é a média",
    x = "Tempo",
    y = "PA"
  ) + guides(color = "none")  

print(grafico_pa)

# ------------------------------------------------------------------------------
# 4. MATRIZ DE CORRELAÇÃO ENTRE TEMPOS
# ------------------------------------------------------------------------------
bd_wide <- bd_pa %>%
  select(id, tempo, PA) %>%
  pivot_wider(names_from = tempo, values_from = PA)

mat_cor <- cor(bd_wide %>% select(-id), use = "pairwise.complete.obs")

corrplot(
  mat_cor,
  method = "color",
  type = "upper",
  tl.col = "black",
  tl.srt = 90,
  addCoef.col = "black",
  col = colorRampPalette(c("#F0F7FF","#D4E8FF","#A6CEFF","#6CA9FF","#2F6ECC"))(200),
  number.cex = 0.8
)

# ------------------------------------------------------------------------------
# 5. MODELAGEM LONGITUDINAL COM GLS
# ------------------------------------------------------------------------------
bd_pa <- bd_pa %>% mutate(tempo_c = tempo - min(tempo))

# Modelo CS (correlação constante)
mod_cs_pa <- gls(
  PA ~ tempo_c * min_atividade_fisica,
  data = bd_pa,
  correlation = corCompSymm(form = ~ 1 | id),
  method = "REML"
)

# Modelo AR1 (correlação decai com o tempo)
mod_ar1_pa <- gls(
  PA ~ tempo_c * min_atividade_fisica,
  data = bd_pa,
  correlation = corAR1(form = ~ tempo_c | id),
  method = "REML"
)

# Modelo SYMM (correlação não estruturada)
mod_symm_pa <- gls(
  PA ~ tempo_c * min_atividade_fisica ,
  data = bd_pa,
  correlation = corSymm(form = ~ 1 | id),
  method = "REML"
)

# ------------------------------------------------------------------------------
# 6. COMPARAÇÃO DOS MODELOS
# ------------------------------------------------------------------------------
print(AIC(mod_cs_pa, mod_ar1_pa, mod_symm_pa))
print(BIC(mod_cs_pa, mod_ar1_pa, mod_symm_pa))

print(anova(mod_cs_pa, mod_ar1_pa))
print(anova(mod_ar1_pa, mod_symm_pa))
print(anova(mod_cs_pa, mod_symm_pa))
```


O modelo GLS com estrutura AR(1) considerando interação é definido por:

$$
Y_{ij} = \beta_0 + \beta_1 \, \text{Tempo Recentralizado}_{j} + \beta_2 \, \text{Min\_Atividade\_Fisica}_{i} + \beta_3 \, (\text{Tempo Recentralizado}_{j} \times \text{Min\_Atividade\_Fisica}_{i}) + \varepsilon_{ij}, 
\quad 
\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \boldsymbol{\Sigma}_{AR1})
$$

onde:  

- $i$ indica o indivíduo (paciente), variando de $i = 1, \dots, 100$;  
- $j$ indica o tempo da medição, variando de $j = 1, \dots, 10$;  
- $\boldsymbol{\Sigma}_{AR1}$ é a matriz de covariância com **correlação decrescente** entre observações consecutivas do mesmo indivíduo:  

$$
\text{Cor}(\varepsilon_{ij}, \varepsilon_{ik}) = \phi^{|j-k|}, \quad \forall \, j \neq k
$$

- $\phi = 0.710$ é a correlação entre observações consecutivas estimada a partir dos dados.

```{r}
summary(mod_ar1_pa)
```

:::

<br>


::: {style="border-top: 2px solid #003366;"}
:::



